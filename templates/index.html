<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>AI Art Assistant — Collage (Serverless)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* Inlined so there are NO external file fetches */
    #video { transform: scaleX(-1); }
    .thumb { height: 80px; cursor: pointer; margin-right: 10px; }
    .img-fluid { max-height: 70vh; object-fit: contain; }
    .progress { height: 10px; }
  </style>
</head>
<body class="bg-light">
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-md-6">
      <div class="position-relative">
        <video id="video" class="border w-100" autoplay playsinline></video>
        <button class="btn btn-primary position-absolute bottom-0 start-0 m-3" onclick="captureAndSend()">Capture and Analyze</button>
      </div>

      <div class="mt-3" id="loading" style="display: none;">
        <div class="progress mb-2">
          <div id="progress" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%"></div>
        </div>
        <p>Analyzing image…</p>
      </div>

      <div id="instructions" class="bg-white p-3 border rounded mt-3">
        <h5>Instructions</h5>
        <p>Select one of the prompting modes:</p>
        <div class="btn-group mb-3">
          <button class="btn btn-outline-secondary" onclick="setMode('general')">Low Specify General</button>
          <button class="btn btn-outline-secondary" onclick="setMode('artifact')">Low Specify Artifact</button>
          <button class="btn btn-outline-secondary" onclick="setMode('direct')">High Specify Artifact</button>
        </div>
        <p><strong>Mode:</strong> <span id="modeLabel">GENERAL</span></p>
        <p>Click the camera button to capture your work. You must submit your response before generating a new one.</p>
      </div>
    </div>

    <div class="col-md-6">
      <img id="overlay" class="img-fluid mb-3 border" alt="analysis result"/>
      <pre id="prompts" class="bg-white p-3 border rounded" style="min-height: 6rem;"></pre>

      <label for="decision" class="form-label">Do you accept the AI prompt?</label>
      <select id="decision" class="form-select mb-3">
        <option value="accept">Accept</option>
        <option value="reject">Reject</option>
        <option value="partially">Partially</option>
      </select>

      <input type="hidden" id="prompt_text">

      <div class="d-flex gap-2">
        <button id="submitBtn" class="btn btn-success" onclick="submitFeedback()">Submit Response</button>
        <button class="btn btn-outline-secondary" onclick="downloadCsv()">Download CSV Log</button>
      </div>
    </div>
  </div>

  <div class="mt-5 border-top pt-3">
    <h5>Previous Images</h5>
    <div id="history" class="d-flex flex-wrap"></div>
  </div>
</div>

<script>
  // ---------- state ----------
  let mode = "general";
  let submissionMade = true;
  let lastRecommendations = null;     // user-facing
  let lastReasons = null;             // hidden rationale
  let lastResultDataURL = "";         // image shown in #overlay
  const HISTORY_KEY = "collage_history_dataurls";
  const logRows = [["timestamp","user_decision","prompts","internal_explanations"]];

  function setMode(selected) {
    mode = selected;
    document.getElementById("modeLabel").innerText = selected.replace("_"," ").toUpperCase();
  }

  // ---------- camera ----------
  function initCamera() {
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => { document.querySelector("#video").srcObject = stream; })
      .catch(() => alert("Camera permission is required."));
  }
  window.addEventListener("DOMContentLoaded", () => {
    initCamera();
    renderHistory(getHistory());
  });

  // ---------- capture → analyze (client-only) ----------
  async function captureAndSend() {
    if (!submissionMade) { alert("Please submit a response before generating a new prompt."); return; }
    const video = document.querySelector("#video");
    if (!video.videoWidth) { alert("Camera not ready yet."); return; }

    const canvas = document.createElement("canvas");
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0);
    const dataURL = canvas.toDataURL("image/png");

    // progress bar (kept from your original)
    document.getElementById("loading").style.display = "block";
    document.getElementById("progress").style.width = "0%";
    let progress = 0;
    const interval = setInterval(() => {
      if (progress >= 100) { clearInterval(interval); return; }
      progress += 2.86;
      document.getElementById("progress").style.width = progress + "%";
    }, 1000);

    const result = analyzeDataURL(dataURL, mode);

    clearInterval(interval);
    document.getElementById("progress").style.width = "100%";

    document.getElementById("prompt_text").value = result.prompts[0] || "";
    document.getElementById("prompts").innerText = (result.prompts || []).join("\n");

    lastResultDataURL = result.overlay_image || dataURL;
    document.getElementById("overlay").src = lastResultDataURL;

    renderHistory(addHistoryItem(lastResultDataURL));
    document.getElementById("loading").style.display = "none";
    submissionMade = false;

    lastRecommendations = result.prompts || [];
    lastReasons = result.internal_explanations || [];
  }

  // ---------- submit + CSV ----------
  async function submitFeedback() {
    const decision = document.querySelector("#decision").value;
    const promptText = document.querySelector("#prompt_text").value;
    if (!promptText) { alert("Please generate an image and prompt before submitting."); return; }

    const ts = new Date().toISOString();
    logRows.push([ts, decision,
      (lastRecommendations || []).join(" | "),
      (lastReasons || []).join(" ; ")
    ]);
    submissionMade = true;

    const btn = document.querySelector("#submitBtn");
    btn.disabled = true; setTimeout(()=>btn.disabled=false, 600);
  }
  function downloadCsv() {
    const csv = logRows.map(r => r.map(v => `"${(v+"").replace(/"/g,'""')}"`).join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = "interactions.csv"; a.click();
    URL.revokeObjectURL(url);
  }

  // ---------- history (local only) ----------
  function addHistoryItem(dataURL) {
    const list = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
    list.push(dataURL);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(list));
    return list;
  }
  function getHistory() { return JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]"); }
  function renderHistory(list) {
    const bar = document.getElementById("history"); bar.innerHTML = "";
    list.slice().reverse().forEach(img => {
      const thumb = document.createElement("img");
      thumb.src = img; thumb.className = "thumb border rounded";
      thumb.onclick = () => document.getElementById("overlay").src = img;
      bar.appendChild(thumb);
    });
  }

  // =========================================================
  // ===== Image analysis + collage recommendations (JS) =====
  // =========================================================
  function analyzeDataURL(dataURL, mode) {
    const img = new Image(); img.src = dataURL;
    const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
    const maxW = 1200, scale = Math.min(1, maxW / img.width || 1);
    canvas.width = Math.round((img.width || 640) * scale);
    canvas.height = Math.round((img.height || 480) * scale);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const gray = toGray(imgData);
    const grad = sobelGrad(gray);

    const f = computeFeatures(imgData, gray, grad);
    const { recs, reasons } = opposeCohesion(f);

    let overlayDataURL = "";
    if (mode === "direct") overlayDataURL = applySyntheticOverlayToCanvas(ctx, canvas.width, canvas.height, f.suggested_region);

    return {
      dominant_color: f.dominant_color,
      features: {
        temperature: f.temperature, colorfulness: f.colorfulness,
        contrast: f.contrast, edge_density: f.edge_density,
        entropy: f.entropy, suggested_region: f.suggested_region
      },
      prompts: recs,
      internal_explanations: reasons,
      overlay_image: overlayDataURL
    };
  }

  // ---- core metrics ----
  function toGray(imgData){const{data,width,height}=imgData;const g=new Uint8ClampedArray(width*height);for(let i=0,j=0;i<data.length;i+=4,j++){g[j]=Math.round(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]);}return{data:g,width:imgData.width,height:imgData.height};}
  function sobelGrad(gray){const{data,width,height}=gray;const gxK=[-1,0,1,-2,0,2,-1,0,1],gyK=[-1,-2,-1,0,0,0,1,2,1];const mag=new Float32Array(width*height);for(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){let gx=0,gy=0,idx=0;for(let ky=-1;ky<=1;ky++){for(let kx=-1;kx<=1;kx++){const p=(y+ky)*width+(x+kx),v=data[p];gx+=gxK[idx]*v;gy+=gyK[idx]*v;idx++;}}mag[y*width+x]=Math.hypot(gx,gy);}}let max=0;for(let i=0;i<mag.length;i++)if(mag[i]>max)max=mag[i];const norm=new Float32Array(mag.length),inv=max>0?1/max:0;for(let i=0;i<mag.length;i++)norm[i]=mag[i]*inv;return{data:norm,width,height};}
  function colorfulnessHasler(imgData){const{data}=imgData;const rg=[],yb=[];for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];rg.push(Math.abs(r-g));yb.push(Math.abs(0.5*(r+g)-b));}const mean=a=>a.reduce((x,c)=>x+c,0)/a.length;const mrg=mean(rg),myb=mean(yb);const srg=Math.sqrt(mean(rg.map(v=>(v-mrg)*(v-mrg)))),syb=Math.sqrt(mean(yb.map(v=>(v-myb)*(v-myb))));return Math.sqrt(srg*srg+syb*syb)+0.3*Math.sqrt(mrg*mrg+myb*myb);}
  function contrastStd(gray){const{data}=gray;const mean=data.reduce((a,c)=>a+c,0)/data.length;const varg=data.reduce((a,c)=>a+(c-mean)*(c-mean),0)/data.length;return Math.sqrt(varg)/255.0;}
  function dominantColorMean(imgData){const{data}=imgData;let r=0,g=0,b=0,n=0;for(let i=0;i<data.length;i+=4){r+=data[i];g+=data[i+1];b+=data[i+2];n++;}return[Math.round(r/n),Math.round(g/n),Math.round(b/n)];}
  function rgb2hsv(r,g,b){const rn=r/255,gn=g/255,bn=b/255;const cmax=Math.max(rn,gn,bn),cmin=Math.min(rn,gn,bn),d=cmax-cmin;let h=0;if(d!==0){if(cmax===rn)h=60*(((gn-bn)/d)%6);else if(cmax===gn)h=60*(((bn-rn)/d)+2);else h=60*(((rn-gn)/d)+4);}if(h<0)h+=360;const s=cmax===0?0:d/cmax,v=cmax;return[h,s,v];}
  function mainHueAndTemp(imgData){const{data}=imgData;let sumH=0,n=0,sumS=0;for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];const[h,s]=rgb2hsv(r,g,b);if(s>0.1){sumH+=h;sumS+=s;n++;}}const hue=n?sumH/n:0;const sat=n?sumS/n:0;const warm=(hue<30)||(hue>330)||(hue>=30&&hue<=60);return{hue,temperature:warm?"warm":"cool",meanS:sat};}
  function gridOccupancy(imgData,gray,grad,rows=3,cols=3){const w=imgData.width,h=imgData.height,masses=[],cellW=Math.floor(w/cols),cellH=Math.floor(h/rows);for(let r=0;r<rows;r++){const row=[];for(let c=0;c<cols;c++){const x0=c*cellW,y0=r*cellH,x1=(c===cols-1)?w:x0+cellW,y1=(r===rows-1)?h:y0+cellH;let sum=0,count=0;for(let y=y0;y<y1;y++){for(let x=x0;x<x1;x++){const p=y*w+x;const invWhite=1-gray.data[p]/255;const gmag=grad.data[p];sum+=0.6*invWhite+0.4*gmag;count++;}}row.push(sum/Math.max(1,count));}masses.push(row);}return masses;}
  function emptiestCell(m){let min=Infinity,mi=0,mj=0;for(let i=0;i<m.length;i++){for(let j=0;j<m[i].length;j++){if(m[i][j]<min){min=m[i][j];mi=i;mj=j;}}}return{i:mi,j:mj,mass:min};}
  function cellName(i,j){const names=[["top left","top center","top right"],["middle left","center","middle right"],["bottom left","bottom center","bottom right"]];return names[Math.max(0,Math.min(2,i))][Math.max(0,Math.min(2,j))];}
  function computeFeatures(imgData,gray,grad){const dom=dominantColorMean(imgData),cf=colorfulnessHasler(imgData),cont=contrastStd(gray);let count=0;for(let k=0;k<grad.data.length;k++){if(grad.data[k]>0.25)count++;}const ed=count/grad.data.length;const hist=new Uint32Array(256);for(let i=0;i<gray.data.length;i++)hist[gray.data[i]]++;let H=0,total=gray.data.length;for(let v=0;v<256;v++){if(!hist[v])continue;const p=hist[v]/total;H-=p*Math.log2(p);}const{hue,temperature,meanS}=mainHueAndTemp(imgData);const masses=gridOccupancy(imgData,gray,grad,3,3);const empty=emptiestCell(masses);const region=cellName(empty.i,empty.j);return{dominant_color:dom,colorfulness:cf,contrast:cont,edge_density:ed,entropy:H,hue,temperature,mean_saturation:meanS,suggested_region:region};}
  function randomDirection(){return["diagonally","vertically","horizontally"][Math.floor(Math.random()*3)];}
  function opposeCohesion(f){const recs=[],reasons=[];const region=f.suggested_region;if(f.temperature==="cool"){recs.push(`Add a **CMY misregistration swatch** (cyan/magenta/yellow blocks) in the ${region}, offset 2–4px per channel.`);reasons.push(`Image skews cool; add warm-biased CMY blocks and misregistration to create chroma conflict near ${region}.`);}else{recs.push(`Overlay a **high-contrast photocopy** rectangle in the ${region}, 5–10° rotated.`);reasons.push(`Image reads warm/saturated (colorfulness=${f.colorfulness.toFixed(1)}); a desaturated photocopy slab opposes palette unity.`);}if(f.edge_density<0.06){recs.push(`Lay a **newsprint halftone dot field** as a translucent sheet across the ${region}, letting dots clash with your smooth areas.`);reasons.push(`Edge density is low (${f.edge_density.toFixed(3)}); halftone dots add micro-structure and noise.`);}else{recs.push(`Place a **masking-tape X** over the ${region}; leave a slight shadow gap.`);reasons.push(`Edges already active (${f.edge_density.toFixed(3)}); a bold tape ‘X’ creates symbolic interruption instead.`);}if(f.contrast<0.12||f.entropy<6.0){recs.push(`Tape a **thin checkerboard strip** running ${randomDirection()} through the ${region}, slightly misaligned.`);reasons.push(`Contrast=${f.contrast.toFixed(2)}, entropy=${f.entropy.toFixed(2)}; a crisp checker strip injects periodic contrast.`);}else{recs.push(`Collage a **ransom-letter word** from mismatched magazines across the ${region}.`);reasons.push(`High image complexity (entropy=${f.entropy.toFixed(2)}); mixed-letter typography shifts attention and breaks semantic cohesion.`);}return{recs,reasons};}
  function applySyntheticOverlayToCanvas(ctx,W,H,regionName){const patch=document.createElement("canvas");const w=Math.floor(W*0.45),h=Math.floor(H*0.25);patch.width=w;patch.height=h;const pctx=patch.getContext("2d");const imgData=pctx.createImageData(w,h);for(let i=0;i<imgData.data.length;i+=4){const val=Math.floor(Math.random()*256);imgData.data[i]=val;imgData.data[i+1]=val;imgData.data[i+2]=val;imgData.data[i+3]=170;}pctx.putImageData(imgData,0,0);const map={"top left":[0.05,0.08],"top center":[0.35,0.08],"top right":[0.65,0.08],"middle left":[0.05,0.38],"center":[0.35,0.38],"middle right":[0.65,0.38],"bottom left":[0.05,0.68],"bottom center":[0.35,0.68],"bottom right":[0.65,0.68]};const anchor=map[regionName]||[0.35,0.38];const x=Math.floor(W*anchor[0]),y=Math.floor(H*anchor[1]);const frame=ctx.getImageData(0,0,W,H);const out=document.createElement("canvas");out.width=W;out.height=H;const octx=out.getContext("2d");octx.putImageData(frame,0,0);octx.drawImage(patch,x,y);return out.toDataURL("image/png");}
</script>
</body>
</html>
