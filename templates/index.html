<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Collage Analyzer (Client-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="./assets/style.css?v=2">
</head>
<body class="bg-light">
  <div class="container py-4">
    <h1 class="h3 mb-4">Collage Analyzer</h1>

    <!-- Upload -->
    <div class="mb-3">
      <label class="form-label">Choose an image</label>
      <input id="fileInput" type="file" accept="image/*" class="form-control" />
    </div>

    <!-- Canvas / Preview -->
    <div class="mb-3">
      <canvas id="canvas" class="w-100 border rounded" style="max-height:70vh;"></canvas>
    </div>

    <!-- Actions -->
    <div class="d-flex flex-wrap gap-2 mb-3">
      <button id="analyzeBtn" class="btn btn-primary">Analyze</button>
      <button id="directBtn" class="btn btn-outline-primary">Analyze + Direct Overlay</button>
      <button id="downloadPngBtn" class="btn btn-outline-secondary" disabled>Download PNG</button>
      <button id="downloadCsvBtn" class="btn btn-outline-secondary">Download CSV Log</button>
    </div>

    <!-- Output -->
    <div class="row g-3">
      <div class="col-md-6">
        <div class="card">
          <div class="card-header">Features</div>
          <div class="card-body">
            <ul id="features" class="mb-0"></ul>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="card">
          <div class="card-header">Recommendations</div>
          <div class="card-body">
            <ul id="recs" class="mb-0"></ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Accept / Skip -->
    <div class="d-flex gap-2 mt-3">
      <button id="acceptBtn" class="btn btn-success">Accept</button>
      <button id="skipBtn" class="btn btn-warning">Skip</button>
      <div id="status" class="ms-2 align-self-center small text-muted"></div>
    </div>

    <!-- History -->
    <div class="mt-4">
      <h2 class="h5">History (this device)</h2>
      <div id="historyGrid" class="d-flex flex-wrap gap-2"></div>
    </div>
  </div>

  <!-- Load your JS AFTER the DOM (defer) -->
  <script src="./assets/app.js" defer></script>
</body>
</html>
  // ---------- history (local only) ----------
  function addHistoryItem(dataURL) {
    const list = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
    list.push(dataURL);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(list));
    return list;
  }
  function getHistory() { return JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]"); }
  function renderHistory(list) {
    const bar = document.getElementById("history"); bar.innerHTML = "";
    list.slice().reverse().forEach(img => {
      const thumb = document.createElement("img");
      thumb.src = img; thumb.className = "thumb border rounded";
      thumb.onclick = () => document.getElementById("overlay").src = img;
      bar.appendChild(thumb);
    });
  }

  // =========================================================
  // ===== Image analysis + collage recommendations (JS) =====
  // =========================================================
  function analyzeDataURL(dataURL, mode) {
    const img = new Image(); img.src = dataURL;
    const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
    const maxW = 1200, scale = Math.min(1, maxW / img.width || 1);
    canvas.width = Math.round((img.width || 640) * scale);
    canvas.height = Math.round((img.height || 480) * scale);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const gray = toGray(imgData);
    const grad = sobelGrad(gray);

    const f = computeFeatures(imgData, gray, grad);
    const { recs, reasons } = opposeCohesion(f);

    let overlayDataURL = "";
    if (mode === "direct") overlayDataURL = applySyntheticOverlayToCanvas(ctx, canvas.width, canvas.height, f.suggested_region);

    return {
      dominant_color: f.dominant_color,
      features: {
        temperature: f.temperature, colorfulness: f.colorfulness,
        contrast: f.contrast, edge_density: f.edge_density,
        entropy: f.entropy, suggested_region: f.suggested_region
      },
      prompts: recs,
      internal_explanations: reasons,
      overlay_image: overlayDataURL
    };
  }

  // ---- core metrics ----
  function toGray(imgData){const{data,width,height}=imgData;const g=new Uint8ClampedArray(width*height);for(let i=0,j=0;i<data.length;i+=4,j++){g[j]=Math.round(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]);}return{data:g,width:imgData.width,height:imgData.height};}
  function sobelGrad(gray){const{data,width,height}=gray;const gxK=[-1,0,1,-2,0,2,-1,0,1],gyK=[-1,-2,-1,0,0,0,1,2,1];const mag=new Float32Array(width*height);for(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){let gx=0,gy=0,idx=0;for(let ky=-1;ky<=1;ky++){for(let kx=-1;kx<=1;kx++){const p=(y+ky)*width+(x+kx),v=data[p];gx+=gxK[idx]*v;gy+=gyK[idx]*v;idx++;}}mag[y*width+x]=Math.hypot(gx,gy);}}let max=0;for(let i=0;i<mag.length;i++)if(mag[i]>max)max=mag[i];const norm=new Float32Array(mag.length),inv=max>0?1/max:0;for(let i=0;i<mag.length;i++)norm[i]=mag[i]*inv;return{data:norm,width,height};}
  function colorfulnessHasler(imgData){const{data}=imgData;const rg=[],yb=[];for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];rg.push(Math.abs(r-g));yb.push(Math.abs(0.5*(r+g)-b));}const mean=a=>a.reduce((x,c)=>x+c,0)/a.length;const mrg=mean(rg),myb=mean(yb);const srg=Math.sqrt(mean(rg.map(v=>(v-mrg)*(v-mrg)))),syb=Math.sqrt(mean(yb.map(v=>(v-myb)*(v-myb))));return Math.sqrt(srg*srg+syb*syb)+0.3*Math.sqrt(mrg*mrg+myb*myb);}
  function contrastStd(gray){const{data}=gray;const mean=data.reduce((a,c)=>a+c,0)/data.length;const varg=data.reduce((a,c)=>a+(c-mean)*(c-mean),0)/data.length;return Math.sqrt(varg)/255.0;}
  function dominantColorMean(imgData){const{data}=imgData;let r=0,g=0,b=0,n=0;for(let i=0;i<data.length;i+=4){r+=data[i];g+=data[i+1];b+=data[i+2];n++;}return[Math.round(r/n),Math.round(g/n),Math.round(b/n)];}
  function rgb2hsv(r,g,b){const rn=r/255,gn=g/255,bn=b/255;const cmax=Math.max(rn,gn,bn),cmin=Math.min(rn,gn,bn),d=cmax-cmin;let h=0;if(d!==0){if(cmax===rn)h=60*(((gn-bn)/d)%6);else if(cmax===gn)h=60*(((bn-rn)/d)+2);else h=60*(((rn-gn)/d)+4);}if(h<0)h+=360;const s=cmax===0?0:d/cmax,v=cmax;return[h,s,v];}
  function mainHueAndTemp(imgData){const{data}=imgData;let sumH=0,n=0,sumS=0;for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];const[h,s]=rgb2hsv(r,g,b);if(s>0.1){sumH+=h;sumS+=s;n++;}}const hue=n?sumH/n:0;const sat=n?sumS/n:0;const warm=(hue<30)||(hue>330)||(hue>=30&&hue<=60);return{hue,temperature:warm?"warm":"cool",meanS:sat};}
  function gridOccupancy(imgData,gray,grad,rows=3,cols=3){const w=imgData.width,h=imgData.height,masses=[],cellW=Math.floor(w/cols),cellH=Math.floor(h/rows);for(let r=0;r<rows;r++){const row=[];for(let c=0;c<cols;c++){const x0=c*cellW,y0=r*cellH,x1=(c===cols-1)?w:x0+cellW,y1=(r===rows-1)?h:y0+cellH;let sum=0,count=0;for(let y=y0;y<y1;y++){for(let x=x0;x<x1;x++){const p=y*w+x;const invWhite=1-gray.data[p]/255;const gmag=grad.data[p];sum+=0.6*invWhite+0.4*gmag;count++;}}row.push(sum/Math.max(1,count));}masses.push(row);}return masses;}
  function emptiestCell(m){let min=Infinity,mi=0,mj=0;for(let i=0;i<m.length;i++){for(let j=0;j<m[i].length;j++){if(m[i][j]<min){min=m[i][j];mi=i;mj=j;}}}return{i:mi,j:mj,mass:min};}
  function cellName(i,j){const names=[["top left","top center","top right"],["middle left","center","middle right"],["bottom left","bottom center","bottom right"]];return names[Math.max(0,Math.min(2,i))][Math.max(0,Math.min(2,j))];}
  function computeFeatures(imgData,gray,grad){const dom=dominantColorMean(imgData),cf=colorfulnessHasler(imgData),cont=contrastStd(gray);let count=0;for(let k=0;k<grad.data.length;k++){if(grad.data[k]>0.25)count++;}const ed=count/grad.data.length;const hist=new Uint32Array(256);for(let i=0;i<gray.data.length;i++)hist[gray.data[i]]++;let H=0,total=gray.data.length;for(let v=0;v<256;v++){if(!hist[v])continue;const p=hist[v]/total;H-=p*Math.log2(p);}const{hue,temperature,meanS}=mainHueAndTemp(imgData);const masses=gridOccupancy(imgData,gray,grad,3,3);const empty=emptiestCell(masses);const region=cellName(empty.i,empty.j);return{dominant_color:dom,colorfulness:cf,contrast:cont,edge_density:ed,entropy:H,hue,temperature,mean_saturation:meanS,suggested_region:region};}
  function randomDirection(){return["diagonally","vertically","horizontally"][Math.floor(Math.random()*3)];}
  function opposeCohesion(f){const recs=[],reasons=[];const region=f.suggested_region;if(f.temperature==="cool"){recs.push(`Add a **CMY misregistration swatch** (cyan/magenta/yellow blocks) in the ${region}, offset 2–4px per channel.`);reasons.push(`Image skews cool; add warm-biased CMY blocks and misregistration to create chroma conflict near ${region}.`);}else{recs.push(`Overlay a **high-contrast photocopy** rectangle in the ${region}, 5–10° rotated.`);reasons.push(`Image reads warm/saturated (colorfulness=${f.colorfulness.toFixed(1)}); a desaturated photocopy slab opposes palette unity.`);}if(f.edge_density<0.06){recs.push(`Lay a **newsprint halftone dot field** as a translucent sheet across the ${region}, letting dots clash with your smooth areas.`);reasons.push(`Edge density is low (${f.edge_density.toFixed(3)}); halftone dots add micro-structure and noise.`);}else{recs.push(`Place a **masking-tape X** over the ${region}; leave a slight shadow gap.`);reasons.push(`Edges already active (${f.edge_density.toFixed(3)}); a bold tape ‘X’ creates symbolic interruption instead.`);}if(f.contrast<0.12||f.entropy<6.0){recs.push(`Tape a **thin checkerboard strip** running ${randomDirection()} through the ${region}, slightly misaligned.`);reasons.push(`Contrast=${f.contrast.toFixed(2)}, entropy=${f.entropy.toFixed(2)}; a crisp checker strip injects periodic contrast.`);}else{recs.push(`Collage a **ransom-letter word** from mismatched magazines across the ${region}.`);reasons.push(`High image complexity (entropy=${f.entropy.toFixed(2)}); mixed-letter typography shifts attention and breaks semantic cohesion.`);}return{recs,reasons};}
  function applySyntheticOverlayToCanvas(ctx,W,H,regionName){const patch=document.createElement("canvas");const w=Math.floor(W*0.45),h=Math.floor(H*0.25);patch.width=w;patch.height=h;const pctx=patch.getContext("2d");const imgData=pctx.createImageData(w,h);for(let i=0;i<imgData.data.length;i+=4){const val=Math.floor(Math.random()*256);imgData.data[i]=val;imgData.data[i+1]=val;imgData.data[i+2]=val;imgData.data[i+3]=170;}pctx.putImageData(imgData,0,0);const map={"top left":[0.05,0.08],"top center":[0.35,0.08],"top right":[0.65,0.08],"middle left":[0.05,0.38],"center":[0.35,0.38],"middle right":[0.65,0.38],"bottom left":[0.05,0.68],"bottom center":[0.35,0.68],"bottom right":[0.65,0.68]};const anchor=map[regionName]||[0.35,0.38];const x=Math.floor(W*anchor[0]),y=Math.floor(H*anchor[1]);const frame=ctx.getImageData(0,0,W,H);const out=document.createElement("canvas");out.width=W;out.height=H;const octx=out.getContext("2d");octx.putImageData(frame,0,0);octx.drawImage(patch,x,y);return out.toDataURL("image/png");}
</script>
</body>
</html>
